> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo
>
> @Range   : 2021-09-19 - 2021-09-25

# Weekly #47

[readme](../README.md) | [previous](202109W3.md) | [next](202109W5.md)

## Table of Contents

- [algorithm](#algorithm-)
- [review](#review-)
    - Go Slices: usage and internals
    - Error handling and Go
- [tip](#tip-)
- [share](#share-)

## algorithm [🔝](#weekly-47)

## review [🔝](#weekly-47)

### 1. [Go Slices: usage and internals](https://go.dev/blog/slices-intro)

1、数组

go 里面的切片是一种特殊的数组，数组是固定长度的。

声明数组的两种方法：

```golang
b := [2]string{"Penn", "Teller"}
b := [...]string{"Penn", "Teller"}
```

在这两种情况下，b 的类型都是 `[2]string`。

2、切片

切片没有指定的长度，它可以自动扩容。

声明切片：

```golang
letters := []string{"a", "b", "c", "d"}
// 内置的 make 方法
func make([]T, len, cap) []T
```

3、切片的内部构造

切片由指向数组的指针、段的长度及其容量 (段的最大长度) 组成：

![](../images/2021/09/slice-struct.png)

当使用 `make([]byte, 5)` 创建时：

![](../images/2021/09/slice-1.png)

当使用切片时 `s = s[2:4]`：

![](../images/2021/09/slice-2.png)

切片不复制切片的数据。它创建一个指向原始数组的新值。这使得切片操作与操作数组索引一样高效。

因此，修改切片的元素会修改原始切片的元素。

这是一篇老早就放到【ReadLater】收藏夹的博客，现在看来很简单，就是介绍了下 slice 的用法和内部结构，不知道当初为啥要收藏？

### 2. [Error handling and Go](https://go.dev/blog/error-handling-and-go)

go 比较有特色的就是错误处理了，像 C 只能返回一个错误码，而 go 可以将返回值和错误一同返回，当然这也是 C 就一个返回值的限制了。

由于引入了这么一个方式，所以 go 代码里面有很多判断返回值中的 err 是否为空，来检查函数是否执行出错，由此也引发出两种写法。

一种是需要使用返回值，这种就需要将函数调用和 err 判空分开写；另一种不需要使用返回值则可以直接放在一行写，就很简洁。

虽然 go 没有像其他语言的 try 代码块，但是这种每次调用函数就检查 err 的写法上逻辑更清晰，一旦错误就进行处理。

像之前写 Python，就是将一大串代码放在 try 里面，我也不知道哪个会执行出错，反正有 except 兜着，写法就很野鸡，当然也没相关开发经验，不知道实际开发时，Python 时如何进行错误处理的。

## tip [🔝](#weekly-47)

## share [🔝](#weekly-47)

[readme](../README.md) | [previous](202109W3.md) | [next](202109W5.md)
