> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo
>
> @Range   : 2024-12-01 - 2024-12-07

# Weekly #91

[readme](../README.md) | [previous](202411W4.md) | [next](202412W2.md)

![](../images/2024/12/roelof-van-wyk-FssdFnEoCo0-unsplash.jpg "Weekly #91")

\**Photo by [Roelof van Wyk](https://unsplash.com/@roelofvwyk) on [Unsplash](https://unsplash.com/photos/a-sea-urchin-sitting-on-top-of-a-sandy-beach-FssdFnEoCo0)*

## Table of Contents

- [algorithm](#algorithm-)
- [review](#review-)
	- 五级页表
- [tip](#tip-)
	- C语言创建动态dll，并调用该dll(visual studio 2013环境下)
- [share](#share-)

## algorithm [🔝](#weekly-91)

## review [🔝](#weekly-91)

### 1. [五级页表（英文）](https://lwn.net/Articles/717293/)

> 作者：Jonathan Corbet  
> 2017年3月15日

2005年初，为Linux 2.6.10合并[四级页表补丁](https://lwn.net/Articles/117749/)是对当时新内核开发模式的早期测试。它证明了社区确实能够合并基础性变更并快速交付给用户——这与2.6.0版本之前普遍存在的多年发布周期形成了鲜明对比。而如今，为4.11-rc2版本（在合并窗口之外）合并五级页表的补丁甚至没有引起多少关注。然而，这一变化意义重大，它揭示了计算行业的发展方向。

页表的作用是将虚拟内存地址映射到实际存储数据的物理地址。从概念上讲，它是一个线性数组，通过虚拟地址（或至少是地址中的页帧号部分）索引，并返回关联物理页的页帧号。然而，这样的数组会非常庞大且极度浪费。大多数进程即使在32位系统上也不会使用完整的可用虚拟地址空间，而在64位系统上，它们甚至只使用了其中极小的一部分。因此，地址空间往往是稀疏分布的，导致该数组的大部分未被使用。

几十年来，硬件中实现的解决方案是将线性数组转换为表示地址空间的稀疏树。结果如下所示：

![](../images/2024/12/four-level-pt.png)

顶部的方框行表示64位虚拟地址的位。为了转换该地址，硬件将地址拆分为多个位字段。注意，在此方案中（对应于x86-64架构的地址使用方式），最高16位被丢弃；虚拟地址中只有低48位被使用。在使用的位中，最高9位（位39-47）用于索引页全局目录（PGD）；每个地址空间有一个单独的页。读取的值是页上层目录（PUD）的地址；虚拟地址的位30-38用于索引指定的PUD页，以获取页中间目录（PMD）的地址。通过位21-29，可以索引PMD以获取最低级别的页表，称为PTE。最后，虚拟地址的位12-20在索引PTE时，将返回包含数据的实际页的物理地址。虚拟地址的最低12位是页内的偏移量。

在页表的任何级别，指向下一级的指针可以为空，表示该范围内没有有效的虚拟地址。这种方案允许缺失大型子树，对应于地址空间中未映射的范围。中间级别还可以有特殊条目，表示它们直接指向一个（大）物理页，而不是指向更低级别的页表；这就是大页的实现方式。例如，一个2MB的大页可以直接在PMD级别找到，而无需中间的PTE页。

可以很快看出，转换虚拟地址的过程将是昂贵的，需要多次从主存中获取数据。这就是为什么转换后备缓冲区（TLB）对系统整体性能如此重要，以及为什么需要更少查找的大页也有助于性能提升。

值得注意的是，并非所有系统都使用四级页表。例如，32位系统使用三级甚至两级页表。内存管理代码的编写方式假设所有四级都存在；通过一些精心编写的代码，确保在内核配置为使用较少级别时，未使用级别的代码会被透明地省略。

在合并四级页表时，您的编辑曾写道：“现在x86-64用户可以拥有覆盖128TB内存的虚拟地址空间，这应该能让他们用上一段时间。”现在看来，“一段时间”可以量化为大约12年。不过，实际上真正的限制似乎是当前x86-64处理器可以寻址的64TB物理内存；正如Kirill Shutemov在[x86五级页表补丁](https://lwn.net/Articles/716916/)中指出的那样，已经有厂商推出了配备如此多内存的系统。

正如该领域常见的情况，解决方案是增加另一层间接性，即第五级页表。新的级别称为“P4D”，插入在PGD和PUD之间。添加这一级别的补丁已合并到4.11-rc2中，尽管目前没有任何硬件支持五级分页。虽然四级页表的添加引起了一些紧张，但五级补丁的合并被描述为“低风险”。目前，内存管理开发人员对添加新级别所需的变更已经有了很好的把握。

为即将推出的Intel处理器添加五级支持的补丁目前计划在4.12版本中发布。运行五级分页的系统将支持52位物理地址和57位虚拟地址。或者，正如Shutemov所说：“它将限制提高到128 PiB的虚拟地址空间和4 PiB的物理地址空间。这‘对任何人来说都足够了’。”新级别还允许创建512GB的大页。

当前的补丁还有一些未解决的问题。其中之一是Xen在启用五级页表的系统上无法工作；它将继续在四级系统上运行。还需要一个启动时标志，以允许在四级和五级分页之间切换，这样发行版就不需要提供两个不同的内核二进制文件。

另一个有趣的问题在补丁系列的[末尾](https://lwn.net/Articles/717300/)有所描述。似乎有一些程序“知道”虚拟地址中只有低48位是有效的。它们利用这一知识，将其他信息编码在最高位中。如果这些位突然成为地址本身的一部分，这些程序显然会崩溃。为了避免此类问题，当前形式的x86补丁默认不会在新的地址空间中分配内存。需要如此多内存且不玩弄虚拟地址的应用程序可以在调用mmap()时提供一个高于边界的地址提示，此时内核将理解可以访问高范围的映射。

任何想要尝试新模式的人现在都可以使用支持五级页表的QEMU进行测试。否则，就需要等待处理器的发布——以及购买配备如此多内存的机器的资金。当硬件可用时，内核应该已经准备好了。

## tip [🔝](#weekly-91)

### 1. [C语言创建动态dll，并调用该dll(visual studio 2013环境下)](https://blog.csdn.net/u014175572/article/details/50728783)

第一部分：创建动态 dll 库。

1、打开 visual studio 创建一个控制台应用程序。

![](../images/2024/12/20160224111146588.jpg)

2、选择 DLL，空项目。

![](../images/2024/12/20160224111150897.jpg)  

3、点击源文件，创建一个 main.c 文件

![](../images/2024/12/20160224111154901.jpg)

4、在 main.c 中写入一个简单的函数，内容如下：

```c
__declspec(dllexport)
	int mymax(int a,int b){
		return a + b;
	}
```

![](../images/2024/12/20160224111158788.jpg)

5、编译生成。

![](../images/2024/12/20160224111202010.jpg)

6、在项目的目录有 dll 和 lib 两个生成好的文件。

![](../images/2024/12/20160224111205089.jpg)

第二部分：在新建项目中使用 dll。

7、新建一个 c 的控制台应用程序 UseDll，把 Dll.dll 放入 Debug 目录下。

![](../images/2024/12/20160224111208089.jpg)

8、把 Dll.lib 放入 UserDll 目录下。

![](../images/2024/12/20160224111210928.jpg)

9、在 UseDll 项目中新建一个源文件 use.c，代码如下：

```
#include<stdio.h>
 
#pragma comment(lib,"Dll.lib")
 
int mymax(int a,int b);
 
int main(){
	printf("调用动态dll函数的结果：%d",mymax(5,6));
	getchar();
	return 0;
}
```

![](../images/2024/12/20160224111213475.jpg)

10、运行结果如下

![](../images/2024/12/20160224111216433.jpg)

## share [🔝](#weekly-91)

[readme](../README.md) | [previous](202411W4.md) | [next](202412W2.md)
