> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo
>
> @Range   : 2020-11-29 - 2020-12-05

# Weekly #5

[readme](../README.md) | [previous](202011W4.md) | [next](202012W2.md)

![](../images/1.jpg "Weekly #5")

\**Photo by Lewis Tian on Unsplash*

## Table of Contents

- [algorithm](#algorithm-)
	- 222.完全二叉树的节点个数
- [review](#review-)
- [tip](#tip-)
	- go 的 \[\] rune 和 \[\] byte 区别（中文）
- [share](#share-)

## algorithm [⬆](#weekly-5)

### 1. [222.完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

给出一个完全二叉树，求出该树的节点个数。

直接递归挺简单的：

```Go
func countNodes(root *TreeNode) int {
	if root == nil {
		return 0
	}
	return 1 + countNodes(root.Left) + countNodes(root.Right);
}
```

官方题解给出了一个二分查找+位运算的解法，好是好，但是面试的时候肯定想不出来：

规定根节点位于第 0 层，完全二叉树的最大层数为 h。

如果第 k 个节点位于第 h 层，则 k 的二进制表示包含 h+1 位，其中最高位是 1，其余各位从高到低表示从根节点到第 k 个节点的路径，0 表示移动到左子节点，1 表示移动到右子节点。通过位运算得到第 k 个节点对应的路径，判断该路径对应的节点是否存在，即可判断第 k 个节点是否存在。

如果第 k 个节点存在，则节点个数一定大于或等于 k，如果第 k 个节点不存在，则节点个数一定小于 k，由此可以将查找的范围缩小一半，直到得到节点个数。

![](../images/w5-algo-1.png)

> 注：sort 包中的 func Search(n int, f func(int) bool) int 解释
>
> Search 采用二分法搜索找到 [0, n) 区间内最小的满足 f(i)==true 的值 i

```Go
func countNodes(root *TreeNode) int {
	if root == nil {
		return 0
	}
	level := 0
	for node := root; node.Left != nil; node = node.Left {
		level++
	}
	return sort.Search(1<<(level+1), func(k int) bool {
		if k <= 1<<level {
			return false
		}
		bits := 1 << (level - 1)
		node := root
		for node != nil && bits > 0 {
			if bits&k == 0 {
				node = node.Left
			} else {
				node = node.Right
			}
			bits >>= 1
		}
		return node == nil
	}) - 1
}
```

## review [⬆](#weekly-5)

## tip [⬆](#weekly-5)

### 1. [go 的 \[\] rune 和 \[\] byte 区别（中文）](https://learnku.com/articles/23411/the-difference-between-rune-and-byte-of-go)

原文是英文，但是对应链接打不开了。

在 go 中，byte 占一个字节，类似 c 中的 char（go 没有 char 这个类型），而 rune 占四个字节，所以 `[]rune(s)` `[]byte(s)` 这俩有啥区别？

```Go
first := "fisrt"
fmt.Println([]rune(first))
fmt.Println([]byte(first))
```

> [102 105 115 114 116] // 输出结果 [] rune  
> [102 105 115 114 116] // 输出结果 [] byte

由于字母根据 ASCII 编码都是一个字节，看不出什么，下面中文就可以看出区别了。

```Go
first := "社区"
fmt.Println([]rune(first))
fmt.Println([]byte(first))
```

> [31038 21306] // 输出结果 [] rune  
> [231 164 190 229 140 186]// 输出结果 [] byte

中文字符串每个占三个字节，当我们像截取若干中文该怎么办？

```Go
s := "截取中文"
//试试这样能不能截取?
fmt.Println(s[:2])
```

> ?? // 输出 在预料之中， 输出了常见的？？

```Go
s := "截取中文"
//试试这样能不能截取?
res := []rune(s)
fmt.Println(string(res[:2]))
```

> 截取 // 输出，顺利截取了

当你直接使用 `s[:2]` 进行截取的时候，底层会将中文转化成 **[]byte**， 而不是 **[]rune**，当我尝试 `fmt.Println(s[:3])` 的时候正常打印出 "截"。

## share [⬆](#weekly-5)

[readme](../README.md) | [previous](202011W4.md) | [next](202012W2.md)
