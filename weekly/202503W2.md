> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo
>
> @Range   : 2025-03-09 - 2025-03-15

# Weekly #105

[readme](../README.md) | [previous](202503W1.md) | [next](202503W3.md)

![](../images/2025/03/photo-nic-H3SStjMB7XY-unsplash.jpg "Weekly #105")

\**Photo by [photo nic](https://unsplash.com/@chiro) on [Unsplash](https://unsplash.com/photos/macro-shot-of-white-veil-H3SStjMB7XY)*

-[toc]

## algorithm [🔝](#weekly-105)

## review [🔝](#weekly-105)

### 1. [《C++11》各种初始化方式的详细列举与对比](https://lizhuo.blog.csdn.net/article/details/144970023)

#### 1. C++98/C++03 的初始化方式

在 C++98 和 C++03 中，主要有以下几种初始化方式：

1. 直接初始化（Direct Initialization）

使用构造函数直接初始化对象。

```C++
int a(5);
std::vector<int> v(5, 1);
```

2. 复制初始化（Copy Initialization）

使用赋值操作符 = 进行初始化。

```C++
int b = 5;
std::vector<int> w = std::vector<int>(5, 1);
```

- 3. 动态初始化（Dynamic Initialization）

使用 `new` 关键字动态分配内存并初始化对象。

```C++
int* p = new int(5);
std::vector<int>* vec = new std::vector<int>(5, 1);
```

4. 列表初始化（List Initialization）

在 C++98/C++03 中并不支持列表初始化，但可以使用初始化列表来初始化数组。

```C++
int arr[5] = {1, 2, 3, 4, 5};
```

#### 2. C++11 及之后的初始化方式

C++11 引入了列表初始化，并对其他初始化方式进行了改进。以下是 C++11 及之后的初始化方式：

1. 列表初始化（List Initialization）

使用大括号 `{}` 来初始化对象。

```C++
int a = {5};
std::vector<int> v = {1, 2, 3};
```

命名列表初始化

可以为元组或结构体的成员命名（C++20 支持）。

```C++
struct Point {
    int x;
    int y;
};

Point p = { .x = 1, .y = 2 };
```

2. 直接初始化（Direct Initialization）

C++11 继续支持直接初始化。

```C++
int a(5);
std::vector<int> v(5, 1);
```

3. 复制初始化（Copy Initialization）

C++11 继续支持复制初始化。

```C++
int b = 5;
std::vector<int> w = {1, 2, 3};
```

4. 动态初始化（Dynamic Initialization）

C++11 继续支持动态初始化。

```C++
int* p = new int(5);
std::vector<int>* vec = new std::vector<int>{1, 2, 3};
```

5. 统一初始化（Uniform Initialization）

C++11 引入的统一初始化方式，使用大括号 `{}`，可以用于所有类型的对象。

```C++
int a{5};
std::vector<int> v{1, 2, 3};
```

6. 初始化类的非静态成员

在类定义中，可以直接使用列表初始化来初始化非静态成员。

```C++
struct Point {
    int x{0};
    int y{0};
};
```

7. 结构体和类的初始化

C++11 允许使用列表初始化来初始化结构体和类。

```C++
struct Point {
    int x;
    int y;
};

Point p{1, 2};
```

#### 3. 各种初始化方式的对比

| 初始化方式 | C++98/C++03 | C++11 及之后 |
|---|---|---|
| 直接初始化 | √ | √ |
| 复制初始化 | √ | √ |
| 动态初始化 | √ | √ |
| 列表初始化 | × | √ |
| 统一初始化 | × | √ |
| 防止窄化转换 | × | √ (仅列表初始化) |
| 初始化类的非静态成员 | × | √ (仅列表初始化) |
| 命名初始化 | × | √ (C++20) |

#### 4. 深入理解 C++11 及以后的新特性

在 C++ 中，特别是 C++11 及以后的版本中，以下几个概念是非常重要的，它们帮助开发者编写更安全和更易于维护的代码。

1. 防止窄化转换

定义：窄化转换（Narrowing Conversion）是指将一个较大范围的类型转换为一个较小范围的类型，这种转换可能会导致数据丢失。例如，将 `double` 转换为 `int`，或者将 `long` 转换为 `short`。

示例：

```C++
double d = 3.14;
int a = d;
```

在 C++11 中，使用列表初始化（如 `{}`）时，编译器会检查是否存在窄化转换。如果存在，编译器会报错，从而防止潜在的数据丢失。

```C++
int a = {3.14};
```

优点：

- 安全性：防止了意外的数据丢失，增强了代码的安全性。
- 可读性：通过编译器的错误提示，开发者可以更清晰地了解潜在的问题。

2. 初始化类的非静态成员

定义：在 C++11 中，可以在类的定义中直接使用列表初始化来初始化非静态成员变量。这种方式使得类的构造更加简洁和直观。

示例：

```C++
struct Point {
    int x{0};
    int y{0};
};

Point p;
```

优点：

- 简洁性：在类定义中直接初始化成员变量，减少了构造函数的复杂性。
- 可读性：使得类的默认状态更加明确，便于理解。

3. 命名初始化

定义：命名初始化（Named Initialization）是指在初始化结构体或类时，可以为成员指定名称。这种特性在 C++20 中得到了正式支持，但在 C++11 中并没有直接的命名初始化语法。

示例（C++20）

```C++
struct Point {
    int x;
    int y;
};

Point p{.x = 1, .y = 2};
```

优点：

- 可读性：通过为成员命名，代码的可读性大大提高，特别是在结构体或类有多个成员时。
- 灵活性：可以在初始化时只指定部分成员，未指定的成员会使用默认值。

注意：在 C++11 中，虽然没有直接的命名初始化语法，但可以通过构造函数或其他方式实现类似的效果。

## tip [🔝](#weekly-105)

## share [🔝](#weekly-105)

[readme](../README.md) | [previous](202503W1.md) | [next](202503W3.md)
