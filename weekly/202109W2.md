> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo
>
> @Range   : 2021-09-10 - 2021-09-10

# Weekly #45

[readme](../README.md) | [previous](202109W1.md) | [next](202109W3.md)

## Table of Contents

- [algorithm](#algorithm-)
- [review](#review-)
    - NetBSD Explained: The Unix System That Can Run on Anything
- [tip](#tip-)
    - golang-redis åˆ¤æ–­ key ä¸å­˜åœ¨è¿˜æ˜¯è¯»å–å‡ºé”™
    - golang-redis åˆ†å¸ƒå¼è‡ªæ—‹é”
    - ä½¿ç”¨ GitHub Actions å°†ä»“åº“é‡Œçš„ Markdown æ–‡ä»¶å®šæ—¶å‘åˆ°æ¨ç‰¹
    - æœ¬åœ°è¿è¡Œ GitHub Actions
- [share](#share-)

## algorithm [ğŸ”](#weekly-45)

## review [ğŸ”](#weekly-45)

### 1. [NetBSD Explained: The Unix System That Can Run on Anything](https://www.makeuseof.com/what-is-netbsd)

ä»€ä¹ˆæ˜¯ NetBSDï¼Ÿ

NetBSD æ˜¯ä¸€ä¸ªå¼€æºçš„æ“ä½œç³»ç»Ÿï¼Œä¸ Linux ä¸€æ ·ï¼ŒNetBSD è‡´åŠ›äºä¸ Unix çš„å¹¿æ³›å…¼å®¹æ€§ï¼Œæä¾›ç±»ä¼¼çš„å®ç”¨ç¨‹åºå’Œè¡Œä¸ºã€‚

NetBSD æ˜¯åŸºäº BSD ç‰ˆæœ¬ï¼ˆBerkeley Software Distributionï¼‰çš„ Unixï¼Œå› æ­¤åç§°ä¸­æœ‰ â€œBSDâ€ã€‚å®ƒæ˜¯ 20 ä¸–çºª 90 å¹´ä»£æ—©æœŸæ”¯æŒ pc çš„ 386/BSD ç‰ˆæœ¬çš„ä¸€ä¸ªåˆ†æ”¯ã€‚

FreeBSD ä¾§é‡äº PC å¹³å°ï¼ŒOpenBSD ä¾§é‡äºå®‰å…¨æ€§ï¼ŒNetBSD ä¾§é‡äºä¸åŒå¹³å°çš„å¯ç§»æ¤æ€§ã€‚è™½ç„¶ NetBSD çœ‹èµ·æ¥åƒå¦ä¸€ä¸ª Linux å‘è¡Œç‰ˆï¼Œä½†æ˜¯æ•´ä¸ªç³»ç»Ÿï¼ŒåŒ…æ‹¬å†…æ ¸å’Œç”¨æˆ·å®ç”¨ç¨‹åºï¼Œæ˜¯ä½œä¸ºä¸€ä¸ªæ•´ä½“ä¸€èµ·å¼€å‘çš„ã€‚è¿™ä¸ Linux å‘è¡Œç‰ˆæ‹¼å‡‘æ¥è‡ªå¤šä¸ªæºçš„ç»„ä»¶çš„æ–¹å¼å½¢æˆäº†é²œæ˜çš„å¯¹æ¯”ã€‚

BSD æœ€åˆæ˜¯åŸºäºè´å°”å®éªŒå®¤çš„ Unix ç³»ç»Ÿï¼Œä½†å¤šå¹´æ¥ä¸å…¶æ¯å…¬å¸ AT&T çš„ç‰ˆæœ¬åˆ†é“æ‰¬é•³ï¼Œå› æ­¤å¯ä»¥å‘å¸ƒä¸€ä¸ªä¸åŒ…å« AT&T ä»£ç çš„ç‰ˆæœ¬ã€‚

è™½ç„¶å®ƒä¸æ˜¯ä¸€ä¸ªå®Œæ•´çš„æ“ä½œç³»ç»Ÿï¼Œä½†è¿™ä¸ªâ€œç½‘ç»œç‰ˆâ€ä¹‹æ‰€ä»¥è¿™ä¹ˆå‘½åï¼Œæ˜¯å› ä¸ºå®ƒåŒ…å«äº†å‡ ä¸ªå…¬å¸ç”¨æ¥åœ¨ä»–ä»¬çš„äº§å“ä¸­å®ç°ç½‘ç»œçš„ TCP/IP ç½‘ç»œä»£ç ã€‚å®ƒç”šè‡³æœ€ç»ˆè¿›å…¥äº†å¾®è½¯çš„ Windows ç³»ç»Ÿã€‚

éšç€è‹±ç‰¹å°” 80386 å¤„ç†å™¨çš„å‡ºç°ï¼Œä¸ªäººç”µè„‘å˜å¾—æ›´åŠ å¼ºå¤§ï¼ŒWilliam joritz å°† BSD ç§»æ¤åˆ° 386 å¤„ç†å™¨ï¼Œä½¿ç”¨ç½‘ç»œç‰ˆæœ¬ä½œä¸ºèµ·ç‚¹ï¼Œä»–å‘å¸ƒäº† 386BSDã€‚Jolitz å¾ˆéš¾è·Ÿä¸Šå…¶ä»–å¼€å‘äººå‘˜ä¸ºæ”¹è¿›ç³»ç»Ÿè€Œå‘é€ç»™ä»–çš„æ‰€æœ‰è¡¥ä¸ï¼Œæ‰€ä»¥é¡¹ç›®çš„åˆ†æ”¯ç«‹å³å‡ºç°äº†ã€‚

ä¸€ä¸ªå°ç»„å¸Œæœ›ç»§ç»­æ”¹è¿› PC ç‰ˆæœ¬ï¼Œè€Œå¦ä¸€ä¸ªå°ç»„åˆ™å¸Œæœ›å…³æ³¨ä¸åŒä½“ç³»ç»“æ„ä¹‹é—´çš„å¯ç§»æ¤æ€§ã€‚å‰è€…æˆä¸º FreeBSDï¼Œåè€…æˆä¸º NetBSDã€‚

å½“å¼€å‘äººå‘˜ Theo de Raadt è¢«è¦æ±‚ä» NetBSD é¡¹ç›®ä¸­è¾èŒåï¼ŒNetBSD åˆè¢«è¿«ç¦»å¼€ï¼Œéšåä»–åˆ›å»ºäº†ä¸€ä¸ªå˜ä½“ OpenBSDï¼Œä¸“æ³¨äºå®‰å…¨æ€§å’Œä»£ç æ­£ç¡®æ€§ã€‚

## tip [ğŸ”](#weekly-45)

### 1. [golang-redis åˆ¤æ–­ key ä¸å­˜åœ¨è¿˜æ˜¯è¯»å–å‡ºé”™](https://cloud.tencent.com/developer/article/1608750)

redis ä¸­æœ‰ä¸€ä¸ªç‰¹æ®Šå€¼ï¼ˆ`redis.Ni`ï¼‰ç”¨æ¥åˆ¤æ–­è¯»å–æ—¶ key ä¸å­˜åœ¨çš„æƒ…å†µï¼š

```golang
// åˆ¤æ–­ key æ˜¯å¦å­˜åœ¨
val, err := client.Get("user:zhangyunfeiVir").Result()
if err == redis.Nil {
    fmt.Println("key2 does not exist")
} else if err != nil {
    panic(err)
} else {
    fmt.Println("è¯»å–ï¼š", val)
}
```

### 2. [golang-redis åˆ†å¸ƒå¼è‡ªæ—‹é”](https://www.codeleading.com/article/73952735728/)

1ã€ä½¿ç”¨ redis çš„ setnx å®ç°äº†ä¸€ä¸ªè‡ªé€‰é”ï¼Œæœ‰ key è¶…æ—¶ï¼ŒåŒæ—¶ä¹Ÿæœ‰æˆ‘ä»¬è°ƒç”¨ redis é“¾æ¥æ—¶çš„è¶…æ—¶ã€‚

> [spin_lock_setnx.go](../code/spin_lock_setnx.go)

```golang
type Lock struct {
    resource string
    value    interface{}
    timeout  time.Duration
    redisCli *redis.ClusterClient //è¿™ä¸ªæ˜¯é“¾æ¥redisé›†ç¾¤çš„cliï¼Œå¯ä»¥è‡ªè¡Œä¿®æ”¹
}

func NewRedis(redisCli *redis.ClusterClient, resource string, value interface{}, timeOut time.Duration) *Lock {
    return &Lock{
        resource: resource,
        value:    value,
        timeout:  timeOut,
        redisCli: redisCli,
    }
}

func (lock *Lock) TryLock() (ok bool, err error) {
    ok, err = lock.redisCli.SetNX(lock.resource, lock.value, lock.timeout).Result()
    //log.Printf("resource:%s, timeout:%v, ok:%v, err:%v\n", lock.resource, lock.timeout, ok, err)

    return
}

func (lock *Lock) Unlock() (err error) {
    err = lock.redisCli.Del(lock.resource).Err()
    return
}

func (lock *Lock) SpinLockUntilTimeOut(ctx context.Context, d time.Duration) (timeOut bool, err error) {
    var (
        now time.Time
        ok  bool
    )

    endTime := time.Now().Add(d)
    for {
        select {
        case <-ctx.Done():
            timeOut = true
            //log.Printf("SpinLockUntilTimeOut at ctx.Done()")
            return

        default:
            now = time.Now()
            if now.After(endTime) {
                timeOut = true
                //log.Printf("SpinLockUntilTimeOut at d")
                return
            }

            ok, err = lock.TryLock()
            if err != nil {
                return
            }

            if ok {
                return
            } else {
                runtime.Gosched()
            }

        }

    }

}
```

2ã€å†…å­˜ç‰ˆ

> [spin_lock_memory.go](../code/spin_lock_memory.go)

```golang
var lockers map[string]map[uint64]chan interface{}
var addLock chan lockImpl
var delLock chan lockImpl
var tranceId uint64

type lockImpl struct {
    delId uint64
    addId chan uint64
    wait  chan interface{}
    key   string
}

func init() {
    lockers = make(map[string]map[uint64]chan interface{})
    addLock = make(chan lockImpl)
    delLock = make(chan lockImpl)
    run()
}

func run() {
    go func() {
        var (
            ok1, ok2     bool
            addLs, delLs map[uint64]chan interface{}
        )

        for {
            select {
            case add := <-addLock:
                if addLs, ok1 = lockers[add.key]; !ok1 {
                    addLs = make(map[uint64]chan interface{})
                }
                tranceId++
                addLs[tranceId] = add.wait
                lockers[add.key] = addLs
                add.addId <- tranceId
                close(add.addId)
                if len(addLs) == 1 {
                    add.wait <- struct{}{}
                    close(add.wait)
                }

            case del := <-delLock:
                if delLs, ok2 = lockers[del.key]; ok2 {
                    delete(delLs, del.delId)
                    for _, v := range delLs {
                        v <- struct{}{}
                        close(v)
                        break
                    }
                }

            }
        }

    }()
}

type Memory struct {
    key string
    id  uint64
}

func (m *Memory) SLock(ctx context.Context) (timeOut bool, err error) {

    l := lockImpl{
        addId: make(chan uint64, 1),
        wait:  make(chan interface{}, 1),
        key:   m.key,
    }
    addLock <- l
    m.id = <-l.addId

    select {
    case <-l.wait:
        return
    case <-ctx.Done():
        timeOut = true
        return
    }

}

func (m *Memory) UnSLock() (err error) {
    l := lockImpl{
        delId: m.id,
        key:   m.key,
    }
    delLock <- l

    return
}

func NewMemory(path string) *Memory {
    return &Memory{
        key: path,
    }
}
```

### 3. ä½¿ç”¨ GitHub Actions å°†ä»“åº“é‡Œçš„ Markdown æ–‡ä»¶å®šæ—¶å‘åˆ°æ¨ç‰¹

- https://github.com/reidjs/markdown-tweet-scheduler

æ‹¿åˆ° twitter çš„å„ä¸ª keyï¼Œç„¶ååˆ©ç”¨ GitHub Actions è¯»å– README æ¥å‘é€ twitterï¼Œæ„Ÿè§‰æœ¬è´¨ä¸Šæ˜¯ä¸€ç§çˆ¬è™«ã€‚

### 4. æœ¬åœ°è¿è¡Œ GitHub Actions

- https://github.com/nektos/act

æŒºæ£’çš„ä¸€ä¸ªä¸œè¥¿ï¼Œåœ¨æœ¬åœ°è¿è¡Œå°±å¯ä»¥ç¡®å®šæ˜¯å¦å†™å¯¹äº†ï¼Œå¯ä»¥ä¸å¿…åƒä¹‹å‰ä¸€æ¬¡æ¬¡æ¨é€æ¥éªŒè¯ã€‚

## share [ğŸ”](#weekly-45)

[readme](../README.md) | [previous](202109W1.md) | [next](202109W3.md)
