> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo
>
> @Range   : 2021-09-10 - 2021-09-10

# Weekly #45

[readme](../README.md) | [previous](202109W1.md) | [next](202109W3.md)

## Table of Contents

- [algorithm](#algorithm-)
- [review](#review-)
- [tip](#tip-)
    - golang-redis åˆ¤æ–­ key ä¸å­˜åœ¨è¿˜æ˜¯è¯»å–å‡ºé”™
    - golang-redis åˆ†å¸ƒå¼è‡ªæ—‹é”
    - ä½¿ç”¨ GitHub Actions å°†ä»“åº“é‡Œçš„ Markdown æ–‡ä»¶å®šæ—¶å‘åˆ°æ¨ç‰¹
    - æœ¬åœ°è¿è¡Œ GitHub Actions
- [share](#share-)

## algorithm [ğŸ”](#weekly-45)

## review [ğŸ”](#weekly-45)

## tip [ğŸ”](#weekly-45)

### 1. [golang-redis åˆ¤æ–­ key ä¸å­˜åœ¨è¿˜æ˜¯è¯»å–å‡ºé”™](https://cloud.tencent.com/developer/article/1608750)

redis ä¸­æœ‰ä¸€ä¸ªç‰¹æ®Šå€¼ï¼ˆ`redis.Ni`ï¼‰ç”¨æ¥åˆ¤æ–­è¯»å–æ—¶ key ä¸å­˜åœ¨çš„æƒ…å†µï¼š

```golang
// åˆ¤æ–­ key æ˜¯å¦å­˜åœ¨
val, err := client.Get("user:zhangyunfeiVir").Result()
if err == redis.Nil {
    fmt.Println("key2 does not exist")
} else if err != nil {
    panic(err)
} else {
    fmt.Println("è¯»å–ï¼š", val)
}
```

### 2. [golang-redis åˆ†å¸ƒå¼è‡ªæ—‹é”](https://www.codeleading.com/article/73952735728/)

1ã€ä½¿ç”¨ redis çš„ setnx å®ç°äº†ä¸€ä¸ªè‡ªé€‰é”ï¼Œæœ‰ key è¶…æ—¶ï¼ŒåŒæ—¶ä¹Ÿæœ‰æˆ‘ä»¬è°ƒç”¨ redis é“¾æ¥æ—¶çš„è¶…æ—¶ã€‚

> [spin_lock_setnx.go](../code/spin_lock_setnx.go)

```golang
type Lock struct {
    resource string
    value    interface{}
    timeout  time.Duration
    redisCli *redis.ClusterClient //è¿™ä¸ªæ˜¯é“¾æ¥redisé›†ç¾¤çš„cliï¼Œå¯ä»¥è‡ªè¡Œä¿®æ”¹
}

func NewRedis(redisCli *redis.ClusterClient, resource string, value interface{}, timeOut time.Duration) *Lock {
    return &Lock{
        resource: resource,
        value:    value,
        timeout:  timeOut,
        redisCli: redisCli,
    }
}

func (lock *Lock) TryLock() (ok bool, err error) {
    ok, err = lock.redisCli.SetNX(lock.resource, lock.value, lock.timeout).Result()
    //log.Printf("resource:%s, timeout:%v, ok:%v, err:%v\n", lock.resource, lock.timeout, ok, err)

    return
}

func (lock *Lock) Unlock() (err error) {
    err = lock.redisCli.Del(lock.resource).Err()
    return
}

func (lock *Lock) SpinLockUntilTimeOut(ctx context.Context, d time.Duration) (timeOut bool, err error) {
    var (
        now time.Time
        ok  bool
    )

    endTime := time.Now().Add(d)
    for {
        select {
        case <-ctx.Done():
            timeOut = true
            //log.Printf("SpinLockUntilTimeOut at ctx.Done()")
            return

        default:
            now = time.Now()
            if now.After(endTime) {
                timeOut = true
                //log.Printf("SpinLockUntilTimeOut at d")
                return
            }

            ok, err = lock.TryLock()
            if err != nil {
                return
            }

            if ok {
                return
            } else {
                runtime.Gosched()
            }

        }

    }

}
```

2ã€å†…å­˜ç‰ˆ

> [spin_lock_memory.go](../code/spin_lock_memory.go)

```golang
var lockers map[string]map[uint64]chan interface{}
var addLock chan lockImpl
var delLock chan lockImpl
var tranceId uint64

type lockImpl struct {
    delId uint64
    addId chan uint64
    wait  chan interface{}
    key   string
}

func init() {
    lockers = make(map[string]map[uint64]chan interface{})
    addLock = make(chan lockImpl)
    delLock = make(chan lockImpl)
    run()
}

func run() {
    go func() {
        var (
            ok1, ok2     bool
            addLs, delLs map[uint64]chan interface{}
        )

        for {
            select {
            case add := <-addLock:
                if addLs, ok1 = lockers[add.key]; !ok1 {
                    addLs = make(map[uint64]chan interface{})
                }
                tranceId++
                addLs[tranceId] = add.wait
                lockers[add.key] = addLs
                add.addId <- tranceId
                close(add.addId)
                if len(addLs) == 1 {
                    add.wait <- struct{}{}
                    close(add.wait)
                }

            case del := <-delLock:
                if delLs, ok2 = lockers[del.key]; ok2 {
                    delete(delLs, del.delId)
                    for _, v := range delLs {
                        v <- struct{}{}
                        close(v)
                        break
                    }
                }

            }
        }

    }()
}

type Memory struct {
    key string
    id  uint64
}

func (m *Memory) SLock(ctx context.Context) (timeOut bool, err error) {

    l := lockImpl{
        addId: make(chan uint64, 1),
        wait:  make(chan interface{}, 1),
        key:   m.key,
    }
    addLock <- l
    m.id = <-l.addId

    select {
    case <-l.wait:
        return
    case <-ctx.Done():
        timeOut = true
        return
    }

}

func (m *Memory) UnSLock() (err error) {
    l := lockImpl{
        delId: m.id,
        key:   m.key,
    }
    delLock <- l

    return
}

func NewMemory(path string) *Memory {
    return &Memory{
        key: path,
    }
}
```

### 3. ä½¿ç”¨ GitHub Actions å°†ä»“åº“é‡Œçš„ Markdown æ–‡ä»¶å®šæ—¶å‘åˆ°æ¨ç‰¹

- https://github.com/reidjs/markdown-tweet-scheduler

æ‹¿åˆ° twitter çš„å„ä¸ª keyï¼Œç„¶ååˆ©ç”¨ GitHub Actions è¯»å– README æ¥å‘é€ twitterï¼Œæ„Ÿè§‰æœ¬è´¨ä¸Šæ˜¯ä¸€ç§çˆ¬è™«ã€‚

### 4. æœ¬åœ°è¿è¡Œ GitHub Actions

- https://github.com/nektos/act

æŒºæ£’çš„ä¸€ä¸ªä¸œè¥¿ï¼Œåœ¨æœ¬åœ°è¿è¡Œå°±å¯ä»¥ç¡®å®šæ˜¯å¦å†™å¯¹äº†ï¼Œå¯ä»¥ä¸å¿…åƒä¹‹å‰ä¸€æ¬¡æ¬¡æ¨é€æ¥éªŒè¯ã€‚

## share [ğŸ”](#weekly-45)

[readme](../README.md) | [previous](202109W1.md) | [next](202109W3.md)
