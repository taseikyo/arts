> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo
>
> @Range   : 2025-03-02 - 2025-03-02

# Weekly #78

[readme](../README.md) | [previous](202408W5.md) | [next](202409W2.md)

![](../images/2024/09/eric-aiden-JTy9bt2418s-unsplash.jpg "Weekly #78")

\**Photo by [Eric Aiden](https://unsplash.com/@ericaiden) on [Unsplash](https://unsplash.com/photos/woman-in-front-of-aquarium-low-light-photography-JTy9bt2418s)*

## Table of Contents

- [algorithm](#algorithm-)
- [review](#review-)
	- C++ 模板的偏特化与全特化
	- C++ 模板的偏特化与全特化
	- C++ 学习 `__attribute__((packed))` 的作用
- [tip](#tip-)
	- 红叶书斋小说下载
- [share](#share-)

## algorithm [🔝](#weekly-78)

## review [🔝](#weekly-78)

### 1. [C++ 模板的偏特化与全特化](https://harttle.land/2015/10/03/cpp-template.html)

模板机制为 C++ 提供了泛型编程的方式，在减少代码冗余的同时仍然可以提供类型安全。特化必须在同一命名空间下进行，可以特化类模板也可以特化函数模板，但类模板可以偏特化和全特化，而函数模板只能全特化。 模板实例化时会优先匹配"模板参数"最相符的那个特化版本。

1、模板的声明

```C++
// 类模板
template <class T1, class T2>
class A{
    T1 data1;
    T2 data2;
};

// 函数模板
template <class T>
T max(const T lhs, const T rhs){   
    return lhs > rhs ? lhs : rhs;
}
```

2、全特化

通过全特化一个模板，可以对一个特定参数集合自定义当前模板，类模板和函数模板都可以全特化。 全特化的模板参数列表应当是空的，并且应当给出"模板实参"列表：

```C++
// 全特化类模板
template <>
class A<int, double>{
    int data1;
    double data2;
};

// 函数模板
template <>
int max(const int lhs, const int rhs){   
    return lhs > rhs ? lhs : rhs;
}
```

注意类模板的全特化时在类名后给出了"模板实参"，但函数模板的函数名后没有给出"模板实参"。 这是因为编译器根据 `int max(const int, const int)` 的函数签名可以推导出来它是 `T max(const T, const T)` 的特化。

3、特化的歧义

上述函数模板不需指定"模板实参"是因为编译器可以通过函数签名来推导，但有时这一过程是有歧义的：

```C++
template <class T>
void f(){ T d; }

template <>
void f(){ int d; }
```

此时编译器不知道 `f()` 是从 `f<T>()` 特化来的，编译时会有错误：

```C++
error: no function template matches function template specialization 'f'
```

这时我们便需要显式指定"模板实参"：

```C++
template <class T>
void f(){ T d; }

template <>
void f<int>(){ int d; }
```

4、偏特化

类似于全特化，偏特化也是为了给自定义一个参数集合的模板，但偏特化后的模板需要进一步的实例化才能形成确定的签名。 值得注意的是函数模板不允许偏特化，这一点在 Effective C++: Item 25 中有更详细的讨论。 偏特化也是以 template 来声明的，需要给出剩余的"模板形参"和必要的"模板实参"。例如：

```C++
template <class T2>
class A<int, T2>{
    ...
};
```

函数模板是不允许偏特化的，下面的声明会编译错：

```C++
template <class T1, class T2>
void f(){}

template <class T2>
void f<int, T2>(){}
```

但函数允许重载，声明另一个函数模板即可替代偏特化的需要：

```C++
template <class T2>
void f(){}              // 注意：这里没有"模板实参"
```

多数情况下函数模板重载就可以完成函数偏特化的需要，一个例外便是 std 命名空间。 std 是一个特殊的命名空间，用户可以特化其中的模板，但不允许添加模板（其实任何内容都是禁止添加的）。 因此在 std 中添加重载函数是不允许的，在 Effective C++: Item 25 中给出了一个更详细的案例。

### 2. [C++ 模板的偏特化与全特化](https://zhuanlan.zhihu.com/p/346400616)

模板定义：模板就是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参数， 从而实现了真正的代码可重用性。模版可以分为两类：

1. 函数模版
2. 类模版

模板定义本身不参与编译，而是编译器根据模板的用户使用模板时提供的类型参数生成代码，再进 行编译。用户提供不同的类型参数，就会实例化出不同的代码。

1、类模板

类模板描述了一组相关的类或数据类型，它们只能通过类型来区分：整数值、指向（或引用）具有全局链接的变量的指针、其他的组合。类模板尤其适用于描述通用但类型安全的数据结构。

类模板使用：

```C++
template <类型形式参数>
    class 类名
    {
     //类声明体;
    };
    
    template <类型形式参数>
    返回类型 类名 <类型> :: 成员函数名1(形式参数)
    {
     //成员函数定义体;
    }

    ... ...
    template <类型形式参数>
    返回类型 类名 <类型> :: 函数名N(形式参数)
    {
  //成员函数定义体;
    }
```

```C++
#include <iostream>
using namespace std;
template<class T>
class Compare {
	public:
	 bool equal(T a,T b);
}
;
template<class T>
bool Compare<T>::equal(T a, T b) {
	return a == b;
}
int main() {
	Compare<int>C;
	C.equal(1,2);
	return 0;
}
```

类模板全特化：限定死模板实现的具体类型；

比如上述这个例子，我们比较 int 类型这种还可以，但是比较 float 这种类型就不行，这时候就需要进行模板特化；

```C++
#include <iostream>
using namespace std;
template<class T>
class Compare {
	public:
	 bool equal(T a,T b);
}
;
template<class T>
bool Compare<T>::equal(T a, T b) {
	return a == b;
}
//模板全特化
template<>
class Compare<float> {
	public:
	 bool equal(float a, float b);
}
;
bool  Compare<float>::equal(float a, float b) {
	return std::abs(a - b) < 10e-3;
}
int main() {
	Compare<int>C;
	cout<<C.equal(1,2)<<endl;
	Compare<float>C2;
	cout<<C2.equal(1.001,1.001)<<endl;
	return 0;
}
```

类模板偏特化：指提供另一份 template 定义式，而其本身仍为 templatized，这是针对于 template 参数更进一步的条件限制所设计出来的一个特化版本。也就是如果这个模板有多个类型，那么只限定其中的一部分;

```C++
#include <iostream>
using namespace std;
template<class T1,class T2>
class Test {
	public:
	 Test(T1 a, T2 b):_a(a),_b(b) {
		cout << "模板化" << endl;
	}
	private:
	T1 _a;
	T2 _b;
}
;
//模板全特化
template<>
class Test<int,int> {
	public:
	 Test(int a, int b) :_a(a), _b(b) {
		cout << "模板全特化" << endl;
	}
	private:
	int _a;
	int _b;
}
;
//模板偏特化
template<class T>
class Test<int,T> {
	public:
	 Test(int a, T b) :_a(a), _b(b) {
		cout << "模板偏特化" << endl;
	}
	private:
	int _a;
	T _b;
}
;
int main() {
	Test<double, double> t1(1.01, 1.01);
	Test<int, int> t2(1, 1);
	Test<int, char*> t3(1, "111");
	return 0;
}
```

2、函数模板

函数模板一般定义：

```C++
template <类型形式参数>      // 类型形式参数即此格式：<typename  形式参数>  或 <class 形式参数>
返回类型  函数名 （形式参数）
{
 //函数定义体;
}
```

```C++
#include <iostream>
using namespace std;
//普通模板
template<class T1,class T2>
bool Compare(T1 a, T2 b) {
	return a == b;
}
int main() {
	cout << Compare(1, 2) << endl;
	return 0;
}
```

函数模板特化和类模板特化本质是一样的，是对模板参数的特殊化处理：

```C++
#include <iostream>
using namespace std;
//普通模板
template<class T1,class T2>
bool Compare(T1 a, T2 b) {
	cout << "普通模板" << endl;
	return a == b;
}
//函数模板特化
template<>
bool Compare(const char* a, const char* b) {
	cout << "函数模板特化" << endl;
	return strcmp(a,b) == 0;
}
int main() {
	cout << Compare(1, 2) << endl;
	cout << Compare("ab","ab") << endl;
	return 0;
}
```

总结

- 函数模板只有特化，没有偏特化；
- 模板、模板的特化和模板的偏特化都存在的情况下，编译器在编译阶段进行匹配，优先特殊的；
- 模板函数不能是虚函数；因为每个包含虚函数的类具有一个 virtual table, 包含该类的所有虚函数的地址，因此 vtable 的大小是确定的。模板只有被使用时才会被实例化，将其声明为虚函数会使 vtable 的大小不确定。所以，成员函数模板不能为虚函数。

### 3. [C++ 学习 `__attribute__((packed))` 的作用](https://blog.csdn.net/skdkjzz/article/details/43852785)

最近在看我们的代码的时候发现声明类型的时候有 `__attribute__((packed))`的结构体类型声明，如下：

```C++
typedef struct Student {
	int SID;
	char SName;
}__attribute__((packed)) Sinfo;
```

不知道是什么意思，查了下知道是如下含义：

1. `__attribute__((packed))`  的作用就是告诉编译器，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐，是 GCC 特有的语法。这个功能是跟操作系统没关系，跟编译器有关，GCC 编译器不是紧凑模式的。在 windows 下用 vc 的编译器也不是紧凑的，用 tc 的编译器就是紧凑的。例如：

- 在 TC 下：`struct my{char ch; int a;} sizeof(int)=2;sizeof(my)=3;`（紧凑模式）
- 在 GCC 下：`struct my{char ch; int a;} sizeof(int)=4;sizeof(my)=8;`（非紧凑模式）
- 在 GCC 下：`struct my{char ch; int a;}__attrubte__((packed)) sizeof(int)=4;sizeof(my)=5`

2. `__attribute__` 关键字主要是用来在函数或数据声明中设置其属性。给函数赋给属性的主要目的在于让编译器进行优化。函数声明中的 `__attribute__((packed))`，就是告诉编译器这个函数不会返回给调用者，以便编译器在优化时去掉不必要的函数返回代码。

GNU C 的一大特色就是 `__attribute__` 机制。`__attribute__` 可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。


## tip [🔝](#weekly-78)

### 1. [红叶书斋小说下载](../code/hongyebookzhai/README.md	)

实现了两种方式下载（[book.py](../code/hongyebookzhai/book.py)）：

- 串行下载（parse_series），入参是首章的链接，保存每章小说到 text 目录下。这是第一波试水的，执行流程是基于当前章节的链接获取本章节的文本以及下一章的链接，然后一路爬下去，效率较低。
- 并行下载（parse_parallel），入参是小说 ID，保存每章小说到此 ID 目录下。主要流程是从小说的首页章节目录表获取所有章节的链接，然后基于设定的 THREAD_COUNT 去并发下载。

[合并](../code/hongyebookzhai/merge.sh) 就很简单了，将对应小说目录下所有章节合并，写入章节名和章节小说，最后输出合并后的小说。

## share [🔝](#weekly-78)

[readme](../README.md) | [previous](202408W5.md) | [next](202409W2.md)
