> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo
>
> @Range   : 2020-11-08 - 2020-11-14

# Weekly #2

[readme](../README.md) | [previous](202011W1.md) | [next](202011W3.md)

![](../images/vasilios-muselimis-BirCcqcSX5U-unsplash.jpg "The Parthenon temple in Athens The Construction began in 447 BC when the Athenian Empire was at the peak of its power. It was completed in 438 BC!!!!! Can you imagine that???? although decoration of the building continued until 432 BC.")

\**Photo by Vasilios Muselimis on Unsplash*

## Table of Contents

- [algorithm](#algorithm-)
- [review](#review-)
- [tip](#tip-)
- [share](#share-)

## algorithm [⬆](#weekly-2)

## review [⬆](#weekly-2)

## tip [⬆](#weekly-2)

1. [std::pair 作为 std::unordered_map 的 key（中文）](https://blog.csdn.net/Bob__yuan/article/details/96737222)

unordered_map 是 C++11 中新加入的容器，底层是用 hash 实现的，对于键值就需要有 hash 函数计算出对应的 hash 值了。

对于 int 和 string 这种基础类型，C++ 提供了计算他们的 hash 值的函数。但是对于 `std::pair` 或者 `std::vector` 这种就没有，编译器会报错："The C++ Standard doesn't provide a hash for this type."。

下面是 unordered_map 的定义：

```C++
template < class Key,                                    // unordered_map::key_type
           class T,                                      // unordered_map::mapped_type
           class Hash = hash<Key>,                       // unordered_map::hasher
           class Pred = equal_to<Key>,                   // unordered_map::key_equal
           class Alloc = allocator< pair<const Key, T> > // unordered_map::allocator_type
           >
class unordered_map;
```

第一个模板参数是键，第二个模板参数是值，第三个模板参数是 hash 函数，第四个模板参数是相等的比较函数，最后一个是分配器。

我们跳到 hash 这个结构的定义部分，如下代码，对于基础类型，都给出了对应的模板特化，也可以看到上面编译错误的报错位置。

```C++
// TEMPLATE STRUCT hash
template<class _Kty>
struct hash: public _Bitwise_hash<_Kty> {
	static constexpr bool _Value = __is_enum(_Kty);
	static_assert(_Value,
	              "The C++ Standard doesn't provide a hash for this type.");
};
template<>
struct hash<bool>: public _Bitwise_hash<bool> {
	// hash functor for bool
};
template<>
struct hash<char>: public _Bitwise_hash<char> {
	// hash functor for char
};
```

所以如果对于自定义类型，或者 hash 类没有提供模板特化的数据类型，那就需要自己定义了，最简单的方法就是：

```C++
struct pair_hash {
	template<class T1, class T2>
	std::size_t operator() (const std::pair<T1, T2>& p) const {
		auto h1 = std::hash<T1> {}(p.first);
		auto h2 = std::hash<T2> {}(p.second);
		return h1 ^ h2;
	}
};

int main() {
	//unordered_map<pair<int, int>, int> error_mmp;			// error
	unordered_map<pair<int, int>, int, pair_hash> ok_mmp;	// ok
}
```

## share [⬆](#weekly-2)

[readme](../README.md) | [previous](202011W1.md) | [next](202011W3.md)

