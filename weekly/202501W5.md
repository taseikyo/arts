> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo
>
> @Range   : 2025-01-26 - 2025-02-01

# Weekly #99

[readme](../README.md) | [previous](202501W4.md) | [next](202501W6.md)

![](../images/2025/01/sittinat-thurdnampetch-TpUvIVq6kcw-unsplash.jpg "Weekly #99")

\**Photo by [Sittinat Thurdnampetch](https://unsplash.com/@mosthurd) on [Unsplash](https://unsplash.com/photos/a-woman-holding-a-sparkler-in-her-hand-TpUvIVq6kcw)*

## Table of Contents

- [algorithm](#algorithm-)
- [review](#review-)
	- Linux 进程标识
- [tip](#tip-)
	- 在线PS工具
- [share](#share-)

## algorithm [🔝](#weekly-99)

## review [🔝](#weekly-99)

### 1. [Linux 进程标识](http://www.wowotech.net/process_management/process_identification.html)

一、概述

本文主要描述在 linux kernel 中如何标识一个或者一组和进程（线程）相关的实体，包括：

- 进程 ID（线程组 ID）
- 线程 ID
- 进程组 ID
- Session ID

需要强调的是本文 focus 在 identification，很多展开的内容会有一系列文档描述。

二、什么是进程 ID（线程组 ID）

一般而言，我们都会定义进程是一个正在执行的程序或者是一个程序的运行实例。程序是一个静态的概念，是存储在磁盘上的二进制可执行文件，包括程序代码和数据（正文段、数据段等）。当程序运行起来成为进程的时候，单纯的程序代码则不能清楚的描述进程，它还需要若干数据结构来描述程序的执行状态（硬件上下文和软件上下文）以及拥有的资源（如地址空间、打开的文件描述符等）。从内核的角度看，进程是一个和系统资源（CPU time、memory 等）分配相关的实体。

在 POSIX 标准中，系统定义了 getpid 函数来获取一个进程的 process ID。在 linux kernel 中，定义如下：

```C
asmlinkage long sys_getpid(void) {
	return current->tgid;
}
```

从字面上看 task_struct 中的 tgid 是 thread group ID，也就是线程组 ID，在 linux kernel 中，进程是有一个或者多个 thread 组成（POSIX 规定多个 thread 要共享一个进程 ID）。对于 linux kernel，每一个 thread 分配一个 task_struct（其中有一个 pid 的标识），这和大部分的 kernel 处理不一样，其他的 kernel 针对一个进程分配一个 task_struct，在该 task_struct 中嵌入了属于该进程的各个线程的数据。正因为如此，linux kernel 创建一个线程组的概念来映射到 POSIX 中的进程概念。

多线程的进程中第一个线程（主线程，group leader）的 pid 等于 tgid，之后，该线程组中的线程都有自己的 pid，但是共享 tgid，也就是传统意义上的进程 ID。task_struct 有一个 group_leader 成员，指向该 task 的 thread group leader，对于 group leader，该成员指向自己的 task_struct 数据结构。

三、什么是线程 ID

线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不独立拥有系统资源，它是与同属一个进程的其它线程共享进程所拥有的全部资源（如地址空间、文件描述符和信号处理）。这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量等资源。进程是资源管理的最小单元，而线程是程序执行的最小单元。除了共享的进程资源，进程中的各个线程也属于自己的资源，具体包括：stack、PC counter 和 CPU 寄存器。

每个线程应该有自己的 ID，就是线程 ID，在 linux kernel 中，每一个 thread 分配一个 task_struct，该结构中的 pid 成员就是线程 ID。在 POSIX 标准中，定义了 pthread_self 来获取线程 ID，linux kernel 采用了 gettid 的系统调用来获取调用者的线程 ID。在 linux kernel 中，定义如下：

```C
asmlinkage long sys_gettid(void) {
	return current->pid;
}
```

POSIX 规定线程 ID 在所属进程中是唯一的，不过在 linux kernel 的实现中，thread ID 是全系统唯一的，当然，考虑到可移植性，Application software 不应该假设这一点。

四、什么是进程组 ID

每个进程属于一个进程组，每个进程组有一个 Leader 进程，也就是进程 ID 等于进程组 ID 的那个进程。进程组有生命周期，它的生命周期开始于进程组 leader 创建进程组，结束于进程组内的最后一个进程离开进程组（可能是进程退出, 或加入其他进程组）。进程组概念的提出主要是由于：

1、和 job control 相关，关于 job control，后续会专门的文档详细描述。

2、 Signal 可以发送给进程组的每一个进程（job control 也使用这个特性。例如 job control signal 会被送给 job（进程组）中的每一个进程）

3、进程同步的时候，父进程可以 wait for 进程组中的任何一个进程

在 POSIX 标准中，系统定义了 getpgid 函数来获取一个进程的 process group ID。在 linux kernel 中，定义如下：

```C
asmlinkage long sys_getpgid(pid_t pid) {
    if (!pid) {
        // 如果 pid 等于 0，那么需要获取当前进程的进程组 ID
        return process_group(current);
    } else {
        // 否则，获取 pid 标识的那个进程对应的进程组 ID
        int retval;
        struct task_struct * p;
        read_lock( & tasklist_lock);
        p = find_task_by_pid(pid);
        retval = -ESRCH;
        if (p) {
            // 是否有权利获取其他进程的进程组 ID
            retval = security_task_getpgid(p);
            if (!retval)
                retval = process_group(p);
        }
        read_unlock( & tasklist_lock);
        return retval;
    }
}

static inline pid_t process_group(struct task_struct * tsk) {
    return tsk->signal->pgrp;
}
```


task_struct 中的 signal 中的 pgrp 成员标识了进程组 ID。从 pgrp 的位置来看，进程组应该是和信号处理相关的，后续会专门的文档详细描述。

五、Session ID

和进程属于进程组类似，每个进程组都属于一个 session，每个 session 有一个 Leader 进程，也就是创建 session 的那个进程，session leader 的 ID 就等于该 session 的 ID。Session 概念的提出和用户登录以及终端编程相关，后续会专门的文档详细描述。

在 POSIX 标准中，系统定义了 getsid 函数来获取 session leader 进程的 process group ID。如果指定的 PID 不是 session leader，将返回错误，但是在 linux kernel 中没有完全遵守这个规定，getsid 函数总是能返回指定 PID 的 session ID，无论该 PID 指向的进程是否是 session leader，具体定义如下：

```C
asmlinkage long sys_getsid(pid_t pid) {
    if (!pid) {
        // 如果 pid 等于 0，那么需要获取当前进程的进程组 ID
        return process_session(current);
    } else {
        // 否则，获取 pid 标识的那个进程对应的进程组 ID
        int retval;
        struct task_struct * p;
        read_lock( & tasklist_lock);
        p = find_task_by_pid(pid);
        retval = -ESRCH;
        if (p) {
            retval = security_task_getsid(p);
            if (!retval)
                retval = process_session(p);
        }
        read_unlock( & tasklist_lock);

        return retval;
    }
}

static inline pid_t process_session(struct task_struct * tsk) {
    return signal_session(tsk->signal);
}

static inline pid_t signal_session(struct signal_struct * sig) {
    return sig->__session;
}
```

task_struct 中的 signal 中的 `__session` 成员标识了进程组 ID。

## tip [🔝](#weekly-99)

### 1. [在线PS工具](https://www.onlinephotosoft.com/)

该网页就是个在线 PS，好用！

## share [🔝](#weekly-99)

[readme](../README.md) | [previous](202501W4.md) | [next](202501W6.md)
