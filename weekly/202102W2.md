> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo
>
> @Range   : 2021-02-07 - 2021-02-13

# Weekly #15

[readme](../README.md) | [previous](202102W1.md) | [next](202102W3.md)

## Table of Contents

- [algorithm](#algorithm-)
- [review](#review-)
	- 你用 TABs 的方式是错误的（英文）
- [tip](#tip-)
	- 使用 MMA 生成加权的词汇云（中文）
	- 为 URL 生成头图
	- Shell 参数传递与默认值
- [share](#share-)

## algorithm [⬆](#weekly-15)

## review [⬆](#weekly-15)

### 1. [你用 TAB 的方式是错误的（英文）](https://anadoxin.org/blog/youre-using-tabs-in-a-wrong-way.html)

tab 和 空格之争由来已久，特别是在 Python 之中，缩进是一个 tab 还是 4 个空格？当然现在有类似 black 的格式化工具就不存在这个争论了。

作者说了 tab 和空格的优点（空格就一个还行），tab 在 GitHub 中渲染代码块效果不好（md 文档渲染为 8 个空格），也就是说不同的渲染引擎会使用不同的空格来渲染 tab，可能是 2 个、4 个甚至是 8 个，所以我觉得使用 4 个空格来替代 tab 更好看。

另外作者提到一个问题，那就是用 tab 对齐的注释，由于一般编辑器都是 4 个空格来显示一个 tab，当变成 8 个空格注释就对齐了，如下面两个图所示：

| 4 空格 tab | 8 空格 tab |
|-|-|
| <img src="../images/2021/02/tabs_03.png"> | <img src="../images/2021/02/tabs_04.png"> |

如何解决这种问题？很显然直接使用 4 个空格缩进就完事了。

## tip [⬆](#weekly-15)

### 1. [使用 MMA 生成加权的词汇云（中文）](https://www.wolfram.com/mathematica/new-in-10/enhanced-image-processing/weighted-word-cloud.html)

不会 MMA（mathematica），偶然搜到这篇文章。

使用 [ImageCollage](http://reference.wolfram.com/language/ref/ImageCollage.html) 创建由在一段文本中出现次数加权的单词列表的词汇云。

导入一段文本并计算单词出现次数：

```Mathematica
In[1]:= (data = Tally[
    ToLowerCase /@ 
     StringCases[ExampleData[{"Text", "ToBeOrNotToBe"}], 
      WordCharacter ..]]) // Short

Out[1]//Short= {{to,15},{be,4},{or,2},<<164>>,{my,1},{sins,1},{remember,1}}
```

以这些单词的出现次数进行加权，创建词汇云：

```Mathematica
In[2]:= images = #2 -> 
     Rasterize[Style[#1, RandomColor[LCHColor[_, 1, _]]], "Image", 
      RasterSize -> 100] & @@@ data;

In[3]:= ImageCollage[images, "Fit", 400, ImagePadding -> 4, Background -> White]
```

原文如下：

![](../images/2021/02/20210204172203.png)

### 2. [为 URL 生成头图](https://thumbnail.ai/)

我不知道使用 "头图" 这个词恰不恰当，就是指一般文章最开头一个宽窄的图片，就像我这个 Weekly 一样，每一篇都会去找一个图片然后裁成 16：9 的宽窄图片，放置在文章开头，我将其称之为 "头图"。

这个网站可以自动生成一个头图，根据你的网站 URL，比如我输入我的 ARTS 的 GitHub 链接，它就自动生成了几张图，根据用途和场景尺寸也不同：

| Facebook + Twitter | Instagram |
|-|-|
| <img src="../images/2021/02/taseikyo_a.png"> | <img src="../images/2021/02/taseikyo_e.png"> |
| <img src="../images/2021/02/taseikyo_b.png"> | <img src="../images/2021/02/taseikyo_f.png"> |
| <img src="../images/2021/02/taseikyo_c.png"> | <img src="../images/2021/02/taseikyo_g.png"> |
| <img src="../images/2021/02/taseikyo_d.png"> | <img src="../images/2021/02/taseikyo_h.png"> |

当然，由于我在 README 放了图片，所以生成的头图中包含了图片，如果没有的话该网站会提供几张样例图片，也可以自行输入图片链接，所以该网站很方便。

### 3. Shell 参数传递与默认值

1、基本传参

```Bash
#!/bin/bash
echo 参数0: $0;
echo 参数1: $1;
echo 参数2: $2;
echo 参数3: $3;
echo 参数4: $4;
```

```Bash
tian@polaris /m/d/GitHub> vim a.sh
tian@polaris /m/d/GitHub> bash a.sh a b c d
参数0: a.sh
参数1: a
参数2: b
参数3: c
参数4: d
```

2、 $\* 与 $@ 区别

- 相同点：都是引用所有参数
- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 "\*" 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）

```Bash
#!/bin/bash

echo "-- \$* 演示 ---"
for i in "$*"; do
    echo $i
done

echo "-- \$@ 演示 ---"
for i in "$@"; do
    echo $i
done
```

```Bash
tian@polaris /m/d/GitHub> bash a.sh 1 2 3
-- $* 演示 ---
1 2 3
-- $@ 演示 ---
1
2
3
```

3、默认参数

1. if 繁琐方式

```Bash
if [ ! $1 ]; then
    $1='default'
fi
```

2. 简单方式

- ${file-xyz}：假如 $file 没有设定，则使用 xyz 作传回值。(空值及非空值时不作处理) 
- ${file:-xyz}：假如 $file 没有设定或为空值，则使用 xyz 作传回值。(非空值时不作处理)
- ${file+xyz}：假如 $file 设为空值或非空值，均使用 xyz 作传回值。(没设定时不作处理)
- ${file:+xyz}：若 $file 为非空值，则使用 xyz 作传回值。(没设定及空值时不作处理)
- ${file=xyz}：若 $file 没设定，则使用 xyz 作传回值，同时将 $file 赋值为 xyz 。(空值及非空值时不作处理)
- ${file:=xyz}：若 $file 没设定或为空值，则使用 xyz 作传回值，同时将 $file 赋值为 xyz 。(非空值时不作处理)
- ${file?xyz}：若 $file 没设定，则将 xyz 输出至 STDERR。(空值及非空值时不作处理)
- ${file:?xyz}：若 $file 没设定或为空值，则将 xyz 输出至 STDERR。(非空值时不作处理)

## share [⬆](#weekly-15)

[readme](../README.md) | [previous](202102W1.md) | [next](202102W3.md)
