> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo
>
> @Range   : 2025-01-12 - 2025-01-18

# Weekly #97

[readme](../README.md) | [previous](202501W2.md) | [next](202501W4.md)

![](../images/2025/01/andrey-zvyagintsev-7N2NUZ9Vr40-unsplash.jpg "Weekly #97")

\**Photo by [Andrey Zvyagintsev](https://unsplash.com/@zvandrei) on [Unsplash](https://unsplash.com/photos/woman-in-black-and-white-long-sleeve-shirt-standing-on-road-during-daytime-7N2NUZ9Vr40)*      

## Table of Contents

- [algorithm](#algorithm-)
	- 字母异位词分组
	- 最长连续序列
- [review](#review-)
	- live 图原理介绍
- [tip](#tip-)
- [share](#share-)

## algorithm [🔝](#weekly-97)

### 1. [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)

#### 题目

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的所有字母得到的一个新单词。

 

示例 1:

输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
示例 2:

输入: strs = [""]
输出: [[""]]
示例 3:

输入: strs = ["a"]
输出: [["a"]]

提示：

- 1 <= strs.length <= 104
- 0 <= strs[i].length <= 100
- strs[i] 仅包含小写字母

#### 解法

> [49.group-anagrams.go](../code/leetcode/49.group-anagrams.go)

```go
func groupAnagrams(strs []string) [][]string {
    if len(strs) == 1 {
        return [][]string{strs}
    }

    maps := make(map[string][]string, 0)
    for _, str := range strs {
        bytes := []byte(str)
        sort.Slice(bytes, func(i, j int) bool {
            return bytes[i] < bytes[j]
        })

        newStr := string(bytes)
        maps[newStr] = append(maps[newStr], str)
    }

    res := make([][]string, 0)
    for _, v := range maps {
        res = append(res, v)
    }

    return res
}
```

数据：8ms 70.07%; 9.23MB 82.70%

### 2. [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked)

#### 题目

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

示例 1：

输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
示例 2：

输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
示例 3：

输入：nums = [1,0,1,2]
输出：3
 

提示：

- 0 <= nums.length <= 105
- -109 <= nums[i] <= 109

#### 解答

> 解题思路：https://leetcode.cn/problems/longest-consecutive-sequence/description/comments/2436490/
>
> 假设题目没有要O(n)的时间复杂度的话，肯定就是先将数组排序后在遍历数组计算最长的连续序列。
>
> 那么该如何只用O(n)的时间复杂度来完成这道题呢?
>
> 排序的目的是为了让连续的数字在物理层面紧挨在一起，不排序的话，现在让它们逻辑上挨在一起就行了。我们可以利用哈希表来实现数字在逻辑方面挨在一起。哈希表的key就是数字，value则为包含key的最长连续序列的长度。
那么现在的问题就变成的如何用value表示包含key的最长连续序列的长度。
遍历数组，将第i位元素num插入哈希表，就存在3种情况：
>
> - 仅num在哈希表中。
> - num-1或者num+1也在哈希表中。
> - num-1和num+1都在哈希表中。
>
> 因为哈希表的value存的是长度，当有新数字插入时，与其相邻的数字长度也需要改变。但是我们不需要把这个连续序列全部都修改，只需要修改这个连续序列的边缘数字，因为连续序列内的数字改变没有意义，我们不会把数字插入到连续序列内

> [128.longest-consecutive-sequence.go](../code/leetcode/128.longest-consecutive-sequence.go)

```go
func longestConsecutive(nums []int) int {
    dict := make(map[int]int)
    for _, num := range nums {
        if _, ok := dict[num]; !ok {
            prev := dict[num-1]
            next := dict[num+1]

            dict[num] += prev+next+1
            dict[num-prev] = dict[num]
            dict[num+next] = dict[num]
        }
    }

    res := 0
    for _, v := range dict {
        if v > res {
            res = v
        }
    }
    return res
}
```

数据：63ms 10.11%; 13.98MB 10.99%

速度最快的解法如下，先排序然后遍历计数：

```go
func longestConsecutive(nums []int) int {
	if len(nums) == 0 {
		return 0
	}
	sort.Ints(nums)
	res := 1
	cur := 1
	for j := 1; j < len(nums); j++ {
		switch nums[j] - nums[j-1] {
		case 1:
			cur++
			res = max(res, cur)
		case 0:
		default:
			cur = 1
		}
	}
	return res
}
```

## review [🔝](#weekly-97)

### 1. [live 图原理介绍](https://github.com/LLLLLayer/Live-Photos)

图片拥有属性，对于大多数图像文件格式，使用 [CGImageSource](https://developer.apple.com/documentation/imageio/cgimagesource) 类型可以有效地读取数据。可以使用 [The Photo Investigator](https://apps.apple.com/us/app/photo-investigator-view-edit/id571574618) 应用查看照片中的所有 Metadata：

![](../images/2025/01/ThePhotoInvestigator.png)

拍摄照片时，Apple 相机会自动为照片添加不同种类的 Metadata。大多数元数据都很好理解，如位置存储在 GPS Metadata 中、相机信息位于 EXIF Metadata 中。

其中 [kCGImagePropertyMakerAppleDictionary](https://developer.apple.com/documentation/imageio/kcgimagepropertymakerappledictionary) 是 Apple 相机拍摄的照片的键值对字典。“17” 是 Maker Apple 中的 LivePhotoVideoIndex，是 Live Photo 的 Identifier Key，完整列表可以参考 [Apple Tags](https://exiftool.org/TagNames/Apple.html)。

Live Photo 需要有特殊 Metadata 的 JPEG 图像：

```Markdown
[kCGImagePropertyMakerAppleDictionary : [17 : <Identifier>]]
```

> [!NOTE]  
> 作者还介绍了如何 将 Live Photo 分解为照片和视频 以及 使用照片和视频创建 Live Photo

## tip [🔝](#weekly-97)

## share [🔝](#weekly-97)

[readme](../README.md) | [previous](202501W2.md) | [next](202501W4.md)
