> @Author  : Lewis Tian (taseikyo@gmail.com)
>
> @Link    : github.com/taseikyo
>
> @Range   : 2021-05-30 - 2021-06-05

# Weekly #31

[readme](../README.md) | [previous](202105W4.md) | [next](202106W2.md)

![](../images/2021/06/aron-yigin-Hnvvtshep3k-unsplash.jpg)

\**Photo by [Aron Yigin](https://unsplash.com/@aronyigin) on [Unsplash](https://unsplash.com/photos/Hnvvtshep3k)*

æ•¢é—®è·¯åœ¨ä½•æ–¹ï¼Ÿ

## Table of Contents

- [algorithm](#algorithm-)
- [review](#review-)
    - Github Action stuck at queue
    - æ¯ä¸ª Python ç¨‹åºå‘˜éƒ½åº”è¯¥çŸ¥é“çš„ 8 ç§æ•°æ®ç»“æ„
    - ç”¨ Docker æŠŠä½ çš„ Python è„šæœ¬å˜æˆä¸€ä¸ªçœŸæ­£çš„ç¨‹åº
- [tip](#tip-)
    - ffmpeg å¸¸ç”¨æ“ä½œæ‰‹å†Œ
    - Scoop å®‰è£… MySQL
    - ä½¿ç”¨ Python å°†åŸå›¾çš„åœ°ç†ä½ç½®æŠ å‡ºæ¥
- [share](#share-)

## algorithm [ğŸ”](#weekly-31)

## review [ğŸ”](#weekly-31)

### 1. [Github Action stuck at queue](https://github.community/t/github-action-stuck-at-queue/16869/141)

åœ¨ 2021/05/16 æ™šä¸Šæˆ‘å°†æœ€æ–°ä¸€æœŸçš„ Weekly push ä¹‹åå‘ç°å¹¶æ²¡æœ‰æ­£å¸¸è§¦å‘ GitHub Actionï¼ŒçŠ¶æ€å˜æˆäº† *Queen*

éšåæˆ‘å‘ç° `taseikyo/taseikyo` åº“çš„ EveOneCat è¡¨æƒ…åŒ…ä¹Ÿæ²¡æœ‰æ›´æ–°ï¼Œç‚¹è¿›å»çœ‹å¯¹åº”çš„ Action çš„çŠ¶æ€ä¹Ÿæ˜¯ *Queen*ï¼Œç„¶åæœåˆ°è¿™ä¸ª

ä¸‹é¢å¾ˆå¤šç•™è¨€éƒ½è¯´æ˜¯é‡åˆ°å¡ä½çš„é—®é¢˜ï¼Œä¸‹é¢æˆ‘çœ‹åˆ°ä¸€ä¸ªç•™è¨€ç»™å‡ºäº†é—®é¢˜åŸå› ï¼Œè¯´æ˜¯ GitHub å‡ºé—®é¢˜äº†ï¼š[Incident with GitHub Actions, API Requests, and GitHub Pages](https://www.githubstatus.com/incidents/zbpwygxwb3gw)

ç„¶åæˆ‘æ¨è¿Ÿäº†æ¨é€æ–° tagï¼Œæ¯•ç«Ÿä¹Ÿè§¦å‘ä¸äº†å¯¹åº”çš„ Action (;;)

æˆ‘åœ¨å–æ¶ˆçš„å¡ä½çš„å‡ ä¸ª Action æ—¶æŠŠå‡ ä¸ªä¹‹å‰è¿è¡Œè¿‡çš„ Action ç»™è«åå…¶å¦™åˆ äº†ï¼ŒçœŸçƒ¦ã€‚

### 2. [æ¯ä¸ª Python ç¨‹åºå‘˜éƒ½åº”è¯¥çŸ¥é“çš„ 8 ç§æ•°æ®ç»“æ„](https://python.plainenglish.io/8-data-structures-every-python-programmer-should-know-acafd46f479b)

Python æœ‰ 4 ä¸ªå†…ç½®çš„æ•°æ®ç»“æ„ï¼šåˆ—è¡¨ã€å­—å…¸ã€å…ƒç»„å’Œé›†åˆ

1ã€æ•°ç»„ï¼ˆåˆ—è¡¨ï¼‰

å¸¸è§çš„é¢è¯•é—®é¢˜ï¼š

- ä»åˆ—è¡¨ä¸­åˆ é™¤å¶æ•°
- åˆå¹¶ä¸¤ä¸ªæ’åºçš„åˆ—è¡¨
- æŸ¥æ‰¾åˆ—è¡¨ä¸­çš„æœ€å°å€¼
- æœ€å¤§å’Œå­åˆ—è¡¨
- æ‰€æœ‰å…ƒç´ çš„ä¹˜æœºï¼ˆproductsï¼‰

2ã€é˜Ÿåˆ—

Deque å…è®¸åˆ›å»ºåŒç«¯é˜Ÿåˆ—ï¼Œå®ƒå¯ä»¥é€šè¿‡ `popleft()` å’Œ `popright()` æ–¹æ³•è®¿é—®é˜Ÿåˆ—çš„ä¸¤ç«¯

```Python
from collections import deque
# Initializing a queue
q = deque()
# Adding elements to a queue
q.append('a')
q.append('b')
q.append('c')
print("Initial queue")
print(q)
# Removing elements from a queue
print("\nElements dequeued from the queue")
print(q.popleft())
print(q.popleft())
print(q.popleft())
print("\nQueue after removing elements")
print(q)
# Uncommenting q.popleft()
# will raise an IndexError
# as queue is now empty
```

å¸¸è§çš„é¢è¯•é—®é¢˜ï¼š

- åè½¬é˜Ÿåˆ—çš„å‰ k ä¸ªå…ƒç´ 
- ä½¿ç”¨é“¾è¡¨å®ç°é˜Ÿåˆ—
- ä½¿ç”¨é˜Ÿåˆ—å®ç°æ ˆ

3ã€æ ˆ

ç”¨ list å®ç°ï¼Œpush æ“ä½œä½¿ç”¨ `append()` æ–¹æ³•ï¼Œpop æ“ä½œä½¿ç”¨ `pop()`

```Python
stack = []
# append() function to push
# element in the stack
stack.append('a')
stack.append('b')
stack.append('c')
print('Initial stack')
print(stack)
# pop() function to pop
# element from stack in
# LIFO order
print('\nElements popped from stack:')
print(stack.pop())
print(stack.pop())
print(stack.pop())
print('\nStack after elements are popped:')
print(stack)
# uncommenting print(stack.pop())
# will cause an IndexError
# as the stack is now empty
```

å¸¸è§çš„é¢è¯•é—®é¢˜ï¼š

- ä½¿ç”¨æ ˆå®ç°ä¸€ä¸ªé˜Ÿåˆ—
- ä½¿ç”¨æ ˆè®¡ç®—åç¼€è¡¨è¾¾å¼
- ä½¿ç”¨æ ˆçš„è·å–ç¬¬äºŒå¤§å…ƒç´ 
- ä½¿ç”¨æ ˆåˆ›å»º main å‡½æ•°

4ã€é“¾è¡¨

é“¾è¡¨ä¸»è¦ç”¨äºåˆ›å»ºé«˜çº§æ•°æ®ç»“æ„ï¼Œå¦‚å›¾å’Œæ ‘ï¼Œæˆ–è€…ç”¨äºéœ€è¦ç»å¸¸åœ¨æ•´ä¸ªç»“æ„ä¸­æ·»åŠ /åˆ é™¤å…ƒç´ çš„ä»»åŠ¡ã€‚

```Python
class Node:
    def __init__(self, dataval=None):
        self.dataval = dataval
        self.nextval = None

class SLinkedList:
    def __init__(self):
        self.headval = None

list1 = SLinkedList()
list1.headval = Node("Mon")
e2 = Node("Tue")
e3 = Node("Wed")
# Link first Node to second node
list1.headval.nextval = e2
# Link second Node to third node
e2.nextval = e3
```

å¸¸è§çš„é¢è¯•é—®é¢˜ï¼š

- æ‰“å°ç»™å®šé“¾è¡¨çš„ä¸­é—´å…ƒç´ 
- ä»æ’åºçš„é“¾è¡¨ä¸­åˆ é™¤é‡å¤çš„å…ƒç´ 
- æ£€æŸ¥å•é“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡
- åˆå¹¶ k æ’åºé“¾è¡¨
- æŸ¥æ‰¾ä¸¤ä¸ªé“¾è¡¨çš„äº¤ç‚¹

5ã€å¾ªç¯é“¾è¡¨

æ ‡å‡†é“¾è¡¨çš„ä¸»è¦ç¼ºç‚¹æ˜¯å¿…é¡»å§‹ç»ˆä» Head èŠ‚ç‚¹å¼€å§‹ã€‚å¾ªç¯é“¾è¡¨é€šè¿‡å°† Tail èŠ‚ç‚¹çš„ç©ºæŒ‡é’ˆæ›¿æ¢ä¸ºæŒ‡å‘ Head èŠ‚ç‚¹çš„æŒ‡é’ˆæ¥ä¿®å¤è¿™ä¸ªé—®é¢˜ã€‚

è¿™ç§è®¾ç½®çš„ä¼˜ç‚¹æ˜¯å¯ä»¥ä»ä»»ä½•èŠ‚ç‚¹å¼€å§‹éå†æ•´ä¸ªåˆ—è¡¨ã€‚

å¸¸è§çš„é¢è¯•é—®é¢˜ï¼š

- æ£€æµ‹é“¾è¡¨ä¸­çš„å¾ªç¯
- åè½¬å¾ªç¯é“¾è¡¨
- ä»¥ç»™å®šå¤§å°çš„ç»„æ¥åè½¬å¾ªç¯é“¾è¡¨ï¼ˆReverse circular linked list in groups of a given sizeï¼‰

6ã€æ ‘

ä¸é“¾è¡¨ä¸€æ ·ï¼Œå®ƒä»¬ç”± Node å¯¹è±¡å¡«å……ï¼Œè¿™äº›å¯¹è±¡åŒ…å«ä¸€ä¸ªæ•°æ®å€¼å’Œä¸€ä¸ªæˆ–å¤šä¸ªæŒ‡é’ˆï¼Œç”¨äºå®šä¹‰å…¶ä¸ç›´æ¥èŠ‚ç‚¹çš„å…³ç³»ã€‚

äºŒå‰æ ‘æœ€å¸¸è§çš„åº”ç”¨æ˜¯äºŒå‰æŸ¥æ‰¾æ ‘ï¼ˆBSTï¼‰

```Python
class Node:
    def __init__(self, data):
        self.left = None
        self.right = None
        self.data = data
    def insert(self, data):
# Compare the new value with the parent node
        if self.data:
            if data < self.data:
                if self.left is None:
                    self.left = Node(data)
                else:
                    self.left.insert(data)
            elif data > self.data:
                if self.right is None:
                    self.right = Node(data)
                else:
                    self.right.insert(data)
        else:
            self.data = data
# Print the tree
    def PrintTree(self):
        if self.left:
            self.left.PrintTree()
        print( self.data),
        if self.right:
            self.right.PrintTree()
# Use the insert method to add nodes
root = Node(12)
root.insert(6)
root.insert(14)
root.insert(3)
root.PrintTree()
```

å¸¸è§çš„é¢è¯•é—®é¢˜ï¼š

- æ£€æŸ¥ä¸¤ä¸ªäºŒå‰æ ‘æ˜¯å¦ç›¸åŒ
- å®ç°äºŒå‰æ ‘çš„å±‚æ¬¡åºéå†
- æ‰“å°äºŒå‰æŸ¥æ‰¾æ ‘çš„å‘¨é•¿
- æ²¿ç€ä¸€æ¡è·¯å¾„æ±‚æ‰€æœ‰èŠ‚ç‚¹çš„å’Œ
- è¿æ¥ä¸€ä¸ªäºŒå‰æ ‘çš„æ‰€æœ‰å…„å¼ŸèŠ‚ç‚¹

7ã€å›¾

æœ‰å‘å›¾ & æ— å‘å›¾

å½“ç”¨çº¯æ–‡æœ¬ç¼–å†™æ—¶ï¼Œå›¾æœ‰ä¸€ä¸ªé¡¶ç‚¹å’Œè¾¹çš„åˆ—è¡¨ï¼š

```Python
V = {a, b, c, d, e}
E = {ab, ac, bd, cd, de}
```

åœ¨ Python ä¸­ï¼Œå›¾æœ€å¥½ä½¿ç”¨å­—å…¸æ¥å®ç°ï¼Œæ¯ä¸ªé¡¶ç‚¹çš„åç§°ä½œä¸ºé”®ï¼Œè¾¹åˆ—è¡¨ä½œä¸ºå€¼ã€‚

```Python
# Create the dictionary with graph elements
graph = {"a": ["b", "c"],
         "b": ["a", "d"],
         "c": ["a", "d"],
         "d": ["e"],
         "e": ["d"]
         }
# Print the graph
print(graph)
```

å¸¸è§çš„é¢è¯•é—®é¢˜ï¼š

- æ£€æµ‹æœ‰å‘å›¾ä¸­çš„å¾ªç¯
- åœ¨æœ‰å‘å›¾ä¸­æŸ¥æ‰¾çˆ¶èŠ‚ç‚¹
- è®¡ç®—æ— å‘å›¾ä¸­çš„è¾¹æ•°
- æ£€æŸ¥ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´æ˜¯å¦å­˜åœ¨è·¯å¾„
- æ±‚ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„

8ã€å“ˆå¸Œè¡¨

![](../images/2021/06/0_HfyO64JnwAPV2sts.png)

ï¼ˆè¿™ä¸ªå›¾ç”»çš„å¾ˆæ£’ï¼Œäºæ˜¯å·è¿‡æ¥äº†ï¼‰

```Python
import pprint

class Hashtable:
    def __init__(self, elements):
        self.bucket_size = len(elements)
        self.buckets = [[] for i in range(self.bucket_size)]
        self._assign_buckets(elements)

    def _assign_buckets(self, elements):
        for key, value in elements:  # calculates the hash of each key
            hashed_value = hash(key)
            # positions the element in the bucket using hash
            index = hashed_value % self.bucket_size
            # adds a tuple in the bucket
            self.buckets[index].append((key, value))

    def get_value(self, input_key):
        hashed_value = hash(input_key)
        index = hashed_value % self.bucket_size
        bucket = self.buckets[index]
        for key, value in bucket:
            if key == input_key:
                return(value)
        return None

    def __str__(self):
        # pformat returns a printable representation of the object
        return pprint.pformat(self.buckets)


if __name__ == "__main__":
    capitals = [
        ('France', 'Paris'),
        ('United States', 'Washington D.C.'),
        ('Italy', 'Rome'),
        ('Canada', 'Ottawa')
    ]
    hashtable = Hashtable(capitals)
    print(hashtable)
    print(f"The capital of Italy is {hashtable.get_value('Italy')}")
```

å¸¸è§çš„é¢è¯•é—®é¢˜ï¼š

- ä¸ä½¿ç”¨å†…ç½®å‡½æ•°ä»å¤´æ„å»ºä¸€ä¸ªå“ˆå¸Œè¡¨
- Word formation using a hash table
- æ‰¾å‡ºä¸¤ä¸ªåŠ èµ·æ¥ç­‰äº K çš„æ•°å­—
- å®ç°å†²çªå¤„ç†çš„å¼€æ”¾å¯»å€
- ä½¿ç”¨å“ˆå¸Œè¡¨æ£€æµ‹åˆ—è¡¨æ˜¯å¦å…·æœ‰å‘¨æœŸæ€§

ä¸é”™çš„ä¸€ç¯‡æ–‡ç« ï¼Œè¯´æ˜¯ Python ä¸­çš„å…«ç§æ•°æ®ç»“æ„ï¼Œå®é™…ä¸Šå°±æ˜¯å°†å…«ç§æ•°æ®ç»“æ„è®²äº†ä¸€éï¼Œç„¶åç”¨ Python å®ç°ï¼Œç„¶åæ¯ä¸ªæ•°æ®ç»“æ„è®²è§£å®Œè¿˜é™„å¸¦æœ‰ä¼˜ç¼ºç‚¹ï¼ˆæˆ‘æ²¡è´´è¿‡æ¥ï¼‰å’Œé¢è¯•é—®é¢˜ï¼Œå¾ˆä¸é”™ï¼Œæ¯”ä¹‹å‰é‚£äº›æ²¡è¥å…»çš„ä¼šå‘˜æ–‡ç« å¼ºå¤šäº† :)

### 3. [ç”¨ Docker æŠŠä½ çš„ Python è„šæœ¬å˜æˆä¸€ä¸ªçœŸæ­£çš„ç¨‹åº](https://python.plainenglish.io/turn-your-python-script-into-a-real-program-with-docker-c200e15d5265)

è¿™ç¯‡æ–‡ç« æ•™ä½ æ€ä¹ˆå°†ä¸€ä¸ª Python è„šæœ¬ Docker åŒ–ï¼Œå¹¶å°† Dockerfile ä¸Šä¼ è‡³ DockerHub ä»¥å®ç°åˆ†äº«

çœ‹ä¸Šå»æ˜¯æŒºç®€å•çš„ï¼Œä¸»è¦å°±æ˜¯ç¼–å†™å¥½ Dockerfileï¼Œç„¶åè¿è¡Œå³å¯

> src/main.py

```Python
#!/usr/bin/env python3
import logging
import os
import time
import sys
from watchdog.observers import Observer
from watchdog.events import LoggingEventHandler

# load variables from environment variables
verbose = int(os.environ.get('VERBOSE', 1))
directory = os.environ.get('DIRECTORY',  os.path.join('tmp'))

if __name__ == "__main__":
    if verbose:
        logging.basicConfig(stream=sys.stdout, level=logging.INFO)

    event_handler = LoggingEventHandler()

    observer = Observer()
    observer.schedule(event_handler, directory, recursive=True)
    observer.start()

    try:
        while True:
            time.sleep(1)
    finally:
        observer.stop()
        observer.join()
```

> requirements.txt

```
watchdog==2.0.2
```

> Dockerfile

```Dockerfile
# first stage
FROM python:3.8 AS builder
COPY requirements.txt .

# install dependencies to the local user directory (eg. /root/.local)
RUN pip install --user -r requirements.txt

# second stage
FROM python:3.8-slim
WORKDIR /code

# copy only the dependencies that are needed for our application and the source files
COPY --from=builder /root/.local /root/.local
COPY ./src .

# update PATH
ENV PATH=/root/.local:$PATH

# make sure you include the -u flag to have our stdout logged
CMD [ "python", "-u", "./main.py" ]
```

## tip [ğŸ”](#weekly-31)

### 1. [ffmpeg å¸¸ç”¨æ“ä½œæ‰‹å†Œ](https://gist.github.com/steven2358/ba153c642fe2bb1e47485962df07c730)

è¿™ä¸ªç½‘é¡µæ”¶é›†äº† ffmpeg ä¸€äº›å¸¸è§æ“ä½œçš„å‘½ä»¤è¡Œï¼Œå¯èƒ½åˆè¡·è·Ÿæˆ‘ä¹‹å‰åšçš„ [FFmpeg Helper](https://github.com/taseikyo/PyQt5-Apps#ffmpeg-helper) å·¥å…·ç›¸åŒï¼Œåªä¸è¿‡æˆ‘æŠŠæˆ‘å¸¸ç”¨çš„å‘½ä»¤åŒ…è£…æˆ GUI äº†

### 2. Scoop å®‰è£… MySQL

å®‰è£…å®Œæˆä¹‹åï¼Œroot å¯†ç ä¸ºç©ºï¼Œå¦‚æœä¸ä¸ºç©ºå¯ä»¥å»å®‰è£…ç›®å½•ä¸‹çš„ `data/<computer name>.err` æŸ¥çœ‹ï¼ˆ`$SCOOP/apps/mysql/current/data/taseikyo.err`ï¼‰

è‡³äºä¿®æ”¹å¯†ç åˆ™ä½¿ç”¨å‘½ä»¤ï¼š

```Bash
mysqladmin -uroot -p<old passwd> password <new passwd>
# å¦‚æ²¡æœ‰å¯†ç ï¼Œä¸”è¦è®¾ç½®ä¸º root
mysqladmin -uroot -p password root
```

### 3. ä½¿ç”¨ Python å°†åŸå›¾çš„åœ°ç†ä½ç½®æŠ å‡ºæ¥

åˆ·åˆ°è¿™ç¯‡ UC æ–‡ç« ï¼ˆ[å¥³å‹åŠ ç­å‘è‡ªæ‹ï¼Œç”·å‹ç”¨å‡ è¡Œä»£ç å‘ç°æƒŠå¤©ç§˜å¯†...](https://mp.weixin.qq.com/s/d9lMLp7iJp3cLsrFo1xU4A)ï¼‰å¾ˆæœ‰æ„æ€ï¼Œäºæ˜¯æ‹¿ä¸€å¼ å›¾ç‰‡è¯•äº†ä¸‹ã€‚

é¦–å…ˆéœ€è¦å®‰è£… exifread åº“ï¼Œä»£ç æŒºåƒåœ¾çš„ï¼Œéœ€è¦ä¿®æ”¹æ‰èƒ½ä½¿ç”¨

```Bash
pip3 install exifread
```

ç„¶åä½¿ç”¨ exifread ä»åŸå›¾ä¸­æå–å‡ºç»çº¬åº¦ï¼Œä¹‹ååˆ©ç”¨ç™¾åº¦åœ°å›¾çš„ API è·å–è¯¦ç»†ä½ç½®

> [extract_gps_info.py](../code/extract_gps_info.py)

```Python
def process_num(x):
    """
    å°† [26, 5, 10243/2000] è½¬åŒ–ä¸º 26Â°5'5.125"
    """
    x_last = eval(str(x[-1]))
    new_x = x[0].num + x[1].num / 60 + x_last / 3600

    return "{:.13f}".format(new_x)


def extract_image(pic_path):
    GPS = {}
    date = ""
    with open(pic_path, "rb") as f:
        tags = exifread.process_file(f)
        date = tags.get("Image DateTime", "0").values
        # çº¬åº¦æ ‡å¿—
        GPS["GPSLatitudeRef"] = tags.get("GPS GPSLatitudeRef", "0").values
        # çº¬åº¦
        GPS["GPSLatitude"] = process_num(tags.get("GPS GPSLatitude", "0").values)
        # ç»åº¦æ ‡å¿—
        GPS["GPSLongitudeRef"] = tags.get("GPS GPSLongitudeRef", "0").values
        # ç»åº¦
        GPS["GPSLongitude"] = process_num(tags.get("GPS GPSLongitude", "0").values)

    return {"GPS_information": GPS, "date_information": date}


def find_address_from_bd(GPS):
    secret_key = "wLyevcXk5QY36hTKmvV5350F"
    if not GPS:
        return "è¯¥ç…§ç‰‡æ— GPSä¿¡æ¯"
    lat, lng = (
        GPS["GPSLatitude"],
        GPS["GPSLongitude"],
    )
    baidu_map_api = (
        f"http://api.map.baidu.com/geocoder/v2/?ak={secret_key}&"
        f"callback=&location={lat},{lng}s&output=json&pois=0"
    )
    r = requests.get(baidu_map_api)
    info = r.json()["result"]

    formatted_address = info["formatted_address"]
    province = info["addressComponent"]["province"]
    city = info["addressComponent"]["city"]
    district = info["addressComponent"]["district"]
    location = info["sematic_description"]
    return formatted_address, province, city, district, location


if __name__ == "__main__":
    data = extract_image("a.jpg")
    info = find_address_from_bd(data)
    print(f"æ‹æ‘„æ—¶é—´ï¼š{data['date_information']}\nç…§ç‰‡æ‹æ‘„åœ°å€ï¼š{info}")
```

æ‰¾äº†å¼ åŸå›¾ï¼Œç¡®å®æ‹¿åˆ°äº†ä¿¡æ¯ï¼š

```
æ‹æ‘„æ—¶é—´ï¼š2021:05:23 18:24:43
ç…§ç‰‡æ‹æ‘„åœ°å€ï¼š('æ¹–åŒ—çœæ­¦æ±‰å¸‚æ´ªå±±åŒºçå–»è·¯933', 'æ¹–åŒ—çœ', 'æ­¦æ±‰å¸‚', 'æ´ªå±±åŒº', 'åä¸­ç§‘æŠ€å¤§å­¦å†…')
```


## share [ğŸ”](#weekly-31)

[readme](../README.md) | [previous](202105W4.md) | [next](202106W2.md)
